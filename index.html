<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
     "<section>\n  <h2>Chapter 1: Advanced Asynchronous Programming</h2>\n  <p>This chapter explores advanced techniques for handling asynchronous operations in Node.js, including Promises, Async/Await, Event Loops, and microtasks. It emphasizes efficient error handling and optimization strategies for asynchronous code.</p>\n\n  <section>\n    <h3>Promises: Creation, Chaining, Error Handling (try...catch)</h3>\n    <p>Promises provide a structured way to handle asynchronous operations, representing a value that may not be available yet. They offer improved readability and error handling compared to callbacks.</p>\n    <h4>Creating Promises</h4>\n    <p>A Promise is created using the `Promise` constructor, which accepts a function with two arguments: `resolve` and `reject`. These functions are used to signal the success or failure of the asynchronous operation.</p>\n    <pre><code>\n      const myPromise = new Promise((resolve, reject) => {\n        // Asynchronous operation here\n        if (/* operation successful */) {\n          resolve(value);\n        } else {\n          reject(error);\n        }\n      });\n    </code></pre>\n    <h4>Chaining Promises</h4>\n    <p>Promises can be chained together using the `.then()` method, which executes when the previous promise resolves. Each `.then()` returns a new promise, allowing for sequential asynchronous operations.</p>\n    <pre><code>\n      myPromise\n        .then(result => {\n          // Process the result\n          return anotherAsyncFunction(result);\n        })\n        .then(anotherResult => {\n          // Process the result of the second promise\n          console.log(anotherResult);\n        })\n        .catch(error => {\n          // Handle any errors in the chain\n          console.error(error);\n        });\n    </code></pre>\n    <h4>Error Handling with try...catch</h4>\n    <p>Use `try...catch` blocks within asynchronous functions, especially when using `async/await`, to handle errors gracefully.  This ensures that errors are caught and handled locally within the function.</p>\n    <pre><code>\n      async function myFunction() {\n        try {\n          const result = await someAsyncFunction();\n          // Process the result\n        } catch (error) {\n          // Handle the error\n          console.error(error);\n        }\n      }\n    </code></pre>\n  </section>\n\n  <section>\n    <h3>Async/Await: Syntactic sugar over Promises, simplifying asynchronous code</h3>\n    <p>Async/Await is syntactic sugar built on top of Promises, making asynchronous code easier to read and write.  The `async` keyword declares an asynchronous function, and the `await` keyword pauses the execution of the function until a Promise resolves.</p>\n    <pre><code>\n      async function fetchData() {\n        try {\n          const response = await fetch('https://example.com/data');\n          const data = await response.json();\n          return data;\n        } catch (error) {\n          console.error('Error fetching data:', error);\n          throw error; // Re-throw the error to be handled further up the chain if needed.\n        }\n      }\n    </code></pre>\n  </section>\n\n  <section>\n    <h3>Event Loop: Understanding its phases, impact on performance, blocking the Event Loop</h3>\n    <p>The Event Loop is the core mechanism that allows Node.js to perform non-blocking I/O operations. Understanding its phases is crucial for optimizing performance.</p>\n    <h4>Event Loop Phases</h4>\n    <ul>\n      <li><strong>Timers:</strong> Executes timers scheduled by `setTimeout` and `setInterval`.</li>\n      <li><strong>Pending callbacks:</strong> Executes I/O callbacks deferred to the next loop iteration.</li>\n      <li><strong>Idle, prepare:</strong> Internal phase.</li>\n      <li><strong>Poll:</strong> Retrieves new I/O events; executes I/O related callbacks.</li>\n      <li><strong>Check:</strong> Executes `setImmediate` callbacks.</li>\n      <li><strong>Close callbacks:</strong> Executes close callbacks, e.g., `socket.on('close', ...)`.</li>\n    </ul>\n    <h4>Impact on Performance</h4>\n    <p>Long-running tasks in any phase can block the Event Loop, causing delays in processing other events.  This leads to reduced responsiveness and overall performance degradation.</p>\n    <h4>Blocking the Event Loop</h4>\n    <p>Avoid synchronous operations like large file reads or CPU-intensive calculations in the main thread.  Offload these tasks to worker threads to prevent blocking the Event Loop.</p>\n  </section>\n\n  <section>\n    <h3>Microtasks: QueueMicrotask, managing microtask priority</h3>\n    <p>Microtasks are tasks that execute immediately after the current task completes and before the next iteration of the Event Loop. Examples include Promise callbacks (`.then()`, `.catch()`, `.finally()`) and tasks added using `queueMicrotask`.  They have higher priority than I/O and timer callbacks.</p>\n    <h4>QueueMicrotask</h4>\n    <p>The `queueMicrotask()` function allows you to schedule a function to be executed as a microtask.</p>\n    <pre><code>\n      queueMicrotask(() => {\n        // This code will execute after the current task completes\n        console.log('This is a microtask.');\n      });\n    </code></pre>\n    <h4>Managing Microtask Priority</h4>\n    <p>Microtasks are executed in a FIFO (First-In, First-Out) order. Avoid creating excessively long microtask queues, as this can delay the execution of I/O and timer callbacks.</p>\n  </section>\n\n  <section>\n    <h3>Timers: setTimeout, setInterval, setImmediate, process.nextTick</h3>\n    <p>Node.js provides several timer functions for scheduling tasks to execute at a later time.</p>\n    <ul>\n      <li><strong>setTimeout:</strong> Executes a function after a specified delay (minimum delay depends on the system).</li>\n      <li><strong>setInterval:</strong> Executes a function repeatedly at a specified interval.</li>\n      <li><strong>setImmediate:</strong> Executes a function at the end of the current Event Loop iteration, after the poll phase.  Guaranteed to run before any timers.</li>\n      <li><strong>process.nextTick:</strong> Executes a function immediately after the current operation completes, before the Event Loop continues.  Has highest priority, but overuse can starve I/O events.</li>\n    </ul>\n    <p>Choose the appropriate timer function based on the desired timing and priority.  `setImmediate` is often preferred over `setTimeout(fn, 0)` because `setImmediate` will always execute *after* the poll phase.  `process.nextTick` should be used sparingly due to its potential to block the Event Loop.</p>\n  </section>\n\n  <section>\n    <h3>Error Handling in Asynchronous Code: Centralized error handling, avoiding unhandled rejections</h3>\n    <p>Effective error handling is crucial for robust asynchronous applications.</p>\n    <h4>Centralized Error Handling</h4>\n    <p>Implement centralized error handling mechanisms, such as global error handlers or error logging services, to capture and log errors that may occur in asynchronous operations.</p>\n    <pre><code>\n      process.on('uncaughtException', (err) => {\n          console.error('Uncaught exception:', err);\n          // Perform cleanup tasks or log the error\n      });\n\n      process.on('unhandledRejection', (reason, promise) => {\n          console.error('Unhandled rejection at:', promise, 'reason:', reason);\n          // Log the unhandled rejection\n      });\n    </code></pre>\n    <h4>Avoiding Unhandled Rejections</h4>\n    <p>Always handle Promise rejections using `.catch()` or `try...catch` blocks to prevent unhandled rejections. Unhandled rejections can lead to application crashes or unexpected behavior.</p>\n    <pre><code>\n      async function myFunction() {\n        try {\n          await someAsyncFunction();\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    </code></pre>\n  </section>\n\n  <section>\n    <h3>Asynchronous Iterators and Generators</h3>\n    <p>Asynchronous iterators and generators allow you to work with asynchronous data streams in a more manageable and readable way. An asynchronous iterator is an object that has a `next()` method that returns a promise that resolves to an object with `value` and `done` properties.</p>\n\n    <h4>Asynchronous Iterators</h4>\n    <pre><code>\n      const asyncIterable = {\n        [Symbol.asyncIterator]() {\n          let i = 0;\n          return {\n            async next() {\n              if (i < 5) {\n                await new Promise(resolve => setTimeout(resolve, 100)); // Simulate async operation\n                return { value: i++, done: false };\n              } else {\n                return { value: undefined, done: true };\n              }\n            }\n          };\n        }\n      };\n\n      (async () => {\n        for await (const item of asyncIterable) {\n          console.log(item);\n        }\n      })();\n    </code></pre>\n\n    <h4>Asynchronous Generators</h4>\n    <p>Asynchronous generators are functions that can be paused and resumed, allowing you to yield asynchronous values. They use the `async` and `yield` keywords.</p>\n    <pre><code>\n      async function* asyncGenerator() {\n        let i = 0;\n        while (i < 5) {\n          await new Promise(resolve => setTimeout(resolve, 100)); // Simulate async operation\n          yield i++;\n        }\n      }\n\n      (async () => {\n        for await (const item of asyncGenerator()) {\n          console.log(item);\n        }\n      })();\n    </code></pre>\n\n    <p>Using asynchronous iterators and generators can greatly simplify working with data streams that involve asynchronous operations like network requests or file reads.</p>\n  </section>\n</section>\n
</body>
</html>