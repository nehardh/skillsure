const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  const fs = require("node:fs");
  const mime = require("mime-types");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseModalities: [
    ],
    responseMimeType: "application/json",
  };
  
    export const courseOutlineAiModel = model.startChat({
      generationConfig,
    history: [
      {
        role: "user",
        parts: [
          {text: "Generate a study material for Python for Exam and level of difficulty will be EASY with summery of course, List of Chapters along with summery for each chapter, Topic list in each chapter, All result in JSON format. And the structure is as follows:\n{\n  \"course_title\": \"Course Name Here\",\n  \"course_type\": \"Exam | Job Interview | Practice | Coding | Others\",\n  \"level_of_difficulty\": \"Easy | Moderate | Complex\",\n  \"course_summary\": \"A short overview of the course objective and key learning outcomes.\",\n  \"chapters\": [\n    {\n      \"chapter_number\": 1,\n      \"chapter_title\": \"Chapter Title\",\n      \"chapter_summary\": \"Brief explanation of what this chapter covers.\",\n      \"topics\": [\n        \"Topic 1\",\n        \"Topic 2\",\n        \"Topic 3\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\",\n          \"Case Study\",\n          \"Code Snippets\"\n        ],\n        \"sample_questions\": [\n          \"What is the difference between X and Y?\",\n          \"Write a code snippet demonstrating Z.\",\n          \"Explain the concept of ABC with an example.\"\n        ]\n      },\n      \"references\": [\n        \"https://example.com/resource-1\",\n        \"https://example.com/resource-2\"\n      ]\n    }\n    // Repeat for more chapters...\n  ],\n  \"exam_tips\": [\n    \"Focus more on Topic A and B from Chapter 3.\",\n    \"Practice code-level problems using real-world APIs.\",\n    \"Revise the event loop concepts in Node.js multiple times.\"\n  ]\n}\n"},
        ],
      },
      {
        role: "model",
        parts: [
          {text: "```json\n{\n  \"course_title\": \"Introduction to Python Programming\",\n  \"course_type\": \"Exam\",\n  \"level_of_difficulty\": \"Easy\",\n  \"course_summary\": \"This course provides a gentle introduction to the Python programming language. It covers fundamental concepts such as data types, variables, control flow, functions, and basic input/output operations. This course is designed for beginners with little to no prior programming experience.\",\n  \"chapters\": [\n    {\n      \"chapter_number\": 1,\n      \"chapter_title\": \"Getting Started with Python\",\n      \"chapter_summary\": \"This chapter introduces Python, its history, why it's popular, and how to install and set it up on your system. It also covers running your first Python program.\",\n      \"topics\": [\n        \"What is Python?\",\n        \"History and Features of Python\",\n        \"Why Learn Python?\",\n        \"Installing Python (Windows, macOS, Linux)\",\n        \"Setting up a Python Development Environment (IDLE, VS Code)\",\n        \"Running Your First Python Program ('Hello, World!')\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\"\n        ],\n        \"sample_questions\": [\n          \"What are two reasons why Python is popular?\",\n          \"Explain the difference between Python 2 and Python 3.\",\n          \"What is an IDE, and why is it useful?\"\n        ]\n      },\n      \"references\": [\n        \"https://www.python.org/\",\n        \"https://realpython.com/installing-python/\"\n      ]\n    },\n    {\n      \"chapter_number\": 2,\n      \"chapter_title\": \"Data Types and Variables\",\n      \"chapter_summary\": \"This chapter explains the different data types available in Python (integers, floats, strings, booleans) and how to store values in variables. It also covers variable naming conventions and basic operations.\",\n      \"topics\": [\n        \"Data Types (Integers, Floats, Strings, Booleans)\",\n        \"Variables: Declaration and Assignment\",\n        \"Variable Naming Rules and Conventions\",\n        \"Basic Arithmetic Operations (+, -, *, /, %)\",\n        \"String Operations (Concatenation, Slicing)\",\n        \"Type Conversion (int(), float(), str())\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\",\n          \"Code Snippets\"\n        ],\n        \"sample_questions\": [\n          \"What is the difference between an integer and a float?\",\n          \"How do you declare a variable in Python?\",\n          \"Write a code snippet to concatenate two strings.\",\n          \"Explain what will happen when trying to add a number and a string without explicitly converting one to the other.\",\n          \"What will be the result of the following expressions: 5 + 3.5, 10 // 3\"\n        ]\n      },\n      \"references\": [\n        \"https://www.w3schools.com/python/python_datatypes.asp\",\n        \"https://realpython.com/python-variables/\"\n      ]\n    },\n    {\n      \"chapter_number\": 3,\n      \"chapter_title\": \"Control Flow: Conditional Statements\",\n      \"chapter_summary\": \"This chapter covers conditional statements (if, elif, else) that allow your program to make decisions based on conditions.\",\n      \"topics\": [\n        \"Boolean Expressions\",\n        \"The `if` Statement\",\n        \"The `else` Statement\",\n        \"The `elif` Statement\",\n        \"Nested `if` Statements\",\n        \"Comparison Operators (==, !=, >, <, >=, <=)\",\n        \"Logical Operators (and, or, not)\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\",\n          \"Code Snippets\"\n        ],\n        \"sample_questions\": [\n          \"Explain the purpose of the `if` statement.\",\n          \"What is the difference between `if`, `elif`, and `else`?\",\n          \"Write a code snippet to check if a number is positive, negative, or zero.\",\n          \"What is the value of 'True and False or True'?\",\n          \"Create a program that check if the user is eligible to vote by age\"\n        ]\n      },\n      \"references\": [\n        \"https://www.w3schools.com/python/python_if_else.asp\",\n        \"https://realpython.com/python-conditional-statements/\"\n      ]\n    },\n    {\n      \"chapter_number\": 4,\n      \"chapter_title\": \"Control Flow: Loops\",\n      \"chapter_summary\": \"This chapter explains how to use loops (for and while) to repeat a block of code multiple times.\",\n      \"topics\": [\n        \"The `for` Loop\",\n        \"Iterating over Lists and Strings\",\n        \"The `while` Loop\",\n        \"The `break` Statement\",\n        \"The `continue` Statement\",\n        \"Nested Loops\",\n        \"The `range()` Function\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\",\n          \"Code Snippets\"\n        ],\n        \"sample_questions\": [\n          \"Explain the purpose of the `for` loop.\",\n          \"Explain the purpose of the `while` loop.\",\n          \"What is the difference between `break` and `continue`?\",\n          \"Write a code snippet to print the numbers from 1 to 10 using a `for` loop.\",\n          \"What is the use of 'range()' function in python for loop?\"\n        ]\n      },\n      \"references\": [\n        \"https://www.w3schools.com/python/python_for_loops.asp\",\n        \"https://realpython.com/python-while-loop/\"\n      ]\n    },\n    {\n      \"chapter_number\": 5,\n      \"chapter_title\": \"Functions\",\n      \"chapter_summary\": \"This chapter introduces functions, which are reusable blocks of code. You'll learn how to define your own functions, pass arguments to them, and return values.\",\n      \"topics\": [\n        \"Defining Functions with `def`\",\n        \"Function Arguments (Positional, Keyword)\",\n        \"Returning Values from Functions\",\n        \"Function Scope (Local vs. Global)\",\n        \"Docstrings (Documenting Functions)\",\n        \"Calling Functions\",\n        \"Default Arguments\"\n      ],\n      \"assessments\": {\n        \"types\": [\n          \"MCQs\",\n          \"Short Answer\",\n          \"Code Snippets\"\n        ],\n        \"sample_questions\": [\n          \"What is a function?\",\n          \"How do you define a function in Python?\",\n          \"What is the difference between local and global scope?\",\n          \"Write a code snippet to define a function that adds two numbers and returns the result.\",\n          \"Create a function that greets the user by name.\"\n        ]\n      },\n      \"references\": [\n        \"https://www.w3schools.com/python/python_functions.asp\",\n        \"https://realpython.com/defining-your-own-python-function/\"\n      ]\n    }\n  ],\n  \"exam_tips\": [\n    \"Focus on understanding the difference between `for` and `while` loops.\",\n    \"Practice writing small functions to solve simple problems.\",\n    \"Review the concepts of data types and variable assignment.\",\n    \"Be prepared to trace the execution of simple code snippets with conditional statements and loops.\",\n    \"Remember the order of operations and how Python evaluates expressions.\"\n  ]\n}\n```"},
        ],
      },
    ],
    });

    export const generateNotesAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate content for each chapter, topic with semantic HTML tags (like <section>, <h2>, <ul>, etc.), no markdown or code blocks. Output should NOT be wrapped in <html>, <head>, or <body>. The chapters should be in the below order only: \n{\n  \"course_title\": \"Node.js - Advanced Concepts (Exam Preparation)\",\n  \"course_type\": \"Exam\",\n  \"level_of_difficulty\": \"Complex\",\n  \"course_summary\": \"This course delves into advanced Node.js concepts critical for building scalable, robust, and efficient server-side applications. It covers asynchronous programming patterns, modular design, working with streams, databases, microservices architecture, testing, security best practices, and deployment strategies. The focus is on developing a deep understanding of Node.js internals and applying this knowledge to solve complex real-world problems, preparing students for advanced Node.js certification exams.\",\n  \"chapters\": [\n    {\n      \"chapter_number\": 1,\n      \"chapter_title\": \"Advanced Asynchronous Programming\",\n      \"chapter_summary\": \"This chapter explores advanced techniques for handling asynchronous operations in Node.js, including Promises, Async/Await, Event Loops, and microtasks. It emphasizes efficient error handling and optimization strategies for asynchronous code.\",\n      \"topics\": [\n        \"Promises: Creation, Chaining, Error Handling (try...catch)\",\n        \"Async/Await: Syntactic sugar over Promises, simplifying asynchronous code\",\n        \"Event Loop: Understanding its phases, impact on performance, blocking the Event Loop\",\n        \"Microtasks: QueueMicrotask, managing microtask priority\",\n        \"Timers: setTimeout, setInterval, setImmediate, process.nextTick\",\n        \"Error Handling in Asynchronous Code: Centralized error handling, avoiding unhandled rejections\",\n        \"Asynchronous Iterators and Generators\"\n      ]\n    },\n    {\n      \"chapter_number\": 2,\n      \"chapter_title\": \"Streams and Buffers\",\n      \"chapter_summary\": \"This chapter covers Node.js Streams (Readable, Writable, Transform, Duplex) and Buffers, focusing on how to efficiently process large amounts of data. It explores backpressure management and custom stream implementations.\",\n      \"topics\": [\n        \"Streams: Readable, Writable, Transform, Duplex\",\n        \"Piping data: stream.pipe()\",\n        \"Backpressure: Handling slow consumers, flow control\",\n        \"Buffers: Creating, manipulating, converting between strings and Buffers\",\n        \"Character Encoding: UTF-8, ASCII, etc.\",\n        \"Implementing Custom Streams: Extending stream classes\",\n        \"Working with file streams for efficient file processing\"\n      ]\n    },\n    {\n      \"chapter_number\": 3,\n      \"chapter_title\": \"Modules and Package Management\",\n      \"chapter_summary\": \"This chapter focuses on advanced module patterns, dependency management using npm/yarn, creating and publishing packages, and understanding the module resolution algorithm.\",\n      \"topics\": [\n        \"Module System: CommonJS, ES Modules (ESM) in Node.js\",\n        \"Module Resolution Algorithm: How Node.js finds modules\",\n        \"npm and yarn: Package installation, versioning, semantic versioning (semver)\",\n        \"package.json: Dependencies, devDependencies, scripts\",\n        \"Creating and Publishing Packages: Writing a modular library, npm publish\",\n        \"Private Modules: Using private npm registries\",\n        \"Module Bundlers: Webpack, Parcel (Basic integration)\"\n      ]\n    },\n    {\n      \"chapter_number\": 4,\n      \"chapter_title\": \"Database Integration and ORMs\",\n      \"chapter_summary\": \"This chapter covers advanced database integration techniques, including connection pooling, transaction management, and using ORMs (Object-Relational Mappers) for interacting with relational databases (e.g., PostgreSQL, MySQL).\",\n      \"topics\": [\n        \"Database Connection Pooling: Efficiently managing database connections\",\n        \"Transaction Management: Ensuring data consistency (ACID properties)\",\n        \"SQL Injection Prevention: Parameterized queries, escaping user input\",\n        \"ORMs: Sequelize, TypeORM (Concepts, basic usage)\",\n        \"NoSQL Databases: MongoDB with Mongoose (Concepts, basic usage)\",\n        \"Data Modeling: Designing database schemas, indexes\",\n        \"Caching Strategies: Redis integration for improved performance\"\n      ]\n    },\n    {\n      \"chapter_number\": 5,\n      \"chapter_title\": \"Microservices Architecture\",\n      \"chapter_summary\": \"This chapter explores the principles of microservices architecture, including service discovery, inter-service communication (REST, gRPC, message queues), and API gateways.\",\n      \"topics\": [\n        \"Microservices Principles: Decentralization, independent deployability, scalability\",\n        \"Service Discovery: Consul, etcd, Kubernetes DNS\",\n        \"Inter-Service Communication: REST APIs, gRPC, message queues (RabbitMQ, Kafka)\",\n        \"API Gateways: Handling routing, authentication, rate limiting\",\n        \"Containerization: Docker, Docker Compose\",\n        \"Orchestration: Kubernetes (Basic concepts: Pods, Services, Deployments)\",\n        \"Event-Driven Architecture: Using message queues for asynchronous communication\"\n      ]\n    },\n    {\n      \"chapter_number\": 6,\n      \"chapter_title\": \"Testing and Debugging\",\n      \"chapter_summary\": \"This chapter covers advanced testing techniques, including unit testing, integration testing, end-to-end testing, and debugging strategies using Node.js debuggers and profiling tools.\",\n      \"topics\": [\n        \"Unit Testing: Mocha, Jest, Chai (Writing effective unit tests)\",\n        \"Integration Testing: Testing interactions between modules\",\n        \"End-to-End Testing: Cypress, Puppeteer (Testing the entire application flow)\",\n        \"Test Coverage: Measuring code coverage\",\n        \"Debugging Techniques: Using Node.js debugger, VS Code debugger\",\n        \"Profiling: Identifying performance bottlenecks using Node.js profiling tools\",\n        \"Logging: Implementing robust logging strategies (Winston, Morgan)\"\n      ]\n    },\n    {\n      \"chapter_number\": 7,\n      \"chapter_title\": \"Security Best Practices\",\n      \"chapter_summary\": \"This chapter explores common security vulnerabilities in Node.js applications and best practices for mitigating them, including authentication, authorization, input validation, and protection against common web attacks.\",\n      \"topics\": [\n        \"Authentication: Passport.js, JWT (JSON Web Tokens), OAuth 2.0\",\n        \"Authorization: Role-based access control (RBAC), access control lists (ACLs)\",\n        \"Input Validation: Preventing injection attacks (SQL injection, XSS, command injection)\",\n        \"Cross-Site Scripting (XSS) Prevention: Sanitizing user input\",\n        \"Cross-Site Request Forgery (CSRF) Prevention: Using CSRF tokens\",\n        \"HTTPS/TLS: Securing communication with SSL certificates\",\n        \"Security Headers: Implementing security headers (e.g., Content-Security-Policy)\",\n        \"Dependency Security: Scanning dependencies for vulnerabilities (npm audit, Snyk)\"\n      ]\n    },\n    {\n      \"chapter_number\": 8,\n      \"chapter_title\": \"Deployment and Production\",\n      \"chapter_summary\": \"This chapter covers strategies for deploying Node.js applications to production environments, including process management, load balancing, monitoring, and scaling.\",\n      \"topics\": [\n        \"Process Management: PM2, Systemd (Ensuring application uptime)\",\n        \"Load Balancing: Nginx, HAProxy (Distributing traffic across multiple instances)\",\n        \"Reverse Proxies: Configuring reverse proxies for security and performance\",\n        \"Monitoring: Prometheus, Grafana (Collecting metrics, setting up alerts)\",\n        \"Logging: Centralized logging (e.g., ELK stack)\",\n        \"Scaling Strategies: Horizontal scaling, vertical scaling\",\n        \"Continuous Integration/Continuous Deployment (CI/CD): Setting up CI/CD pipelines\"\n      ]\n    }\n  ],\n  \"exam_tips\": [\n    \"Thoroughly understand asynchronous programming concepts and the Node.js event loop.\",\n    \"Practice implementing various stream transformations and backpressure handling techniques.\",\n    \"Master module management and package publishing using npm/yarn.\",\n    \"Gain hands-on experience with database integration using ORMs and NoSQL databases.\",\n    \"Understand the principles of microservices architecture and different inter-service communication patterns.\",\n    \"Become proficient in writing unit, integration, and end-to-end tests.\",\n    \"Familiarize yourself with security best practices and common vulnerabilities in Node.js applications.\",\n    \"Learn different deployment strategies and tools for managing and monitoring Node.js applications in production.\",\n    \"Review the official Node.js documentation and relevant community resources.\",\n    \"Practice solving complex coding problems related to Node.js.\"\n  ]\n}"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "<section>\n  <h2>Chapter 1: Advanced Asynchronous Programming</h2>\n  <p>This chapter explores advanced techniques for handling asynchronous operations in Node.js, including Promises, Async/Await, Event Loops, and microtasks. It emphasizes efficient error handling and optimization strategies for asynchronous code.</p>\n  <ul>\n    <li><h3>Promises: Creation, Chaining, Error Handling (try...catch)</h3>\n        <p>Learn how to create, chain, and handle errors in Promises using <code>try...catch</code> blocks.</p></li>\n    <li><h3>Async/Await: Syntactic sugar over Promises, simplifying asynchronous code</h3>\n        <p>Explore how <code>async/await</code> simplifies asynchronous code, making it more readable and maintainable.</p></li>\n    <li><h3>Event Loop: Understanding its phases, impact on performance, blocking the Event Loop</h3>\n        <p>Gain a deep understanding of the Event Loop phases and how it impacts application performance. Learn how to avoid blocking the Event Loop.</p></li>\n    <li><h3>Microtasks: QueueMicrotask, managing microtask priority</h3>\n        <p>Understand microtasks and how to manage their priority using <code>queueMicrotask</code>.</p></li>\n    <li><h3>Timers: setTimeout, setInterval, setImmediate, process.nextTick</h3>\n        <p>Explore different timers in Node.js and their use cases: <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, and <code>process.nextTick</code>.</p></li>\n    <li><h3>Error Handling in Asynchronous Code: Centralized error handling, avoiding unhandled rejections</h3>\n        <p>Learn how to implement centralized error handling in asynchronous code and avoid unhandled rejections.</p></li>\n    <li><h3>Asynchronous Iterators and Generators</h3>\n        <p>Discover asynchronous iterators and generators for handling asynchronous data streams.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 2: Streams and Buffers</h2>\n  <p>This chapter covers Node.js Streams (Readable, Writable, Transform, Duplex) and Buffers, focusing on how to efficiently process large amounts of data. It explores backpressure management and custom stream implementations.</p>\n  <ul>\n    <li><h3>Streams: Readable, Writable, Transform, Duplex</h3>\n        <p>Understand the different types of Streams in Node.js: Readable, Writable, Transform, and Duplex.</p></li>\n    <li><h3>Piping data: stream.pipe()</h3>\n        <p>Learn how to use <code>stream.pipe()</code> to efficiently pipe data between streams.</p></li>\n    <li><h3>Backpressure: Handling slow consumers, flow control</h3>\n        <p>Explore backpressure and how to handle slow consumers using flow control mechanisms.</p></li>\n    <li><h3>Buffers: Creating, manipulating, converting between strings and Buffers</h3>\n        <p>Learn how to create, manipulate, and convert between strings and Buffers.</p></li>\n    <li><h3>Character Encoding: UTF-8, ASCII, etc.</h3>\n        <p>Understand different character encodings like UTF-8 and ASCII.</p></li>\n    <li><h3>Implementing Custom Streams: Extending stream classes</h3>\n        <p>Learn how to implement custom streams by extending stream classes.</p></li>\n    <li><h3>Working with file streams for efficient file processing</h3>\n        <p>Explore how to work with file streams for efficient file processing.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 3: Modules and Package Management</h2>\n  <p>This chapter focuses on advanced module patterns, dependency management using npm/yarn, creating and publishing packages, and understanding the module resolution algorithm.</p>\n  <ul>\n    <li><h3>Module System: CommonJS, ES Modules (ESM) in Node.js</h3>\n        <p>Understand the CommonJS and ES Modules (ESM) module systems in Node.js.</p></li>\n    <li><h3>Module Resolution Algorithm: How Node.js finds modules</h3>\n        <p>Learn how Node.js resolves modules using the module resolution algorithm.</p></li>\n    <li><h3>npm and yarn: Package installation, versioning, semantic versioning (semver)</h3>\n        <p>Explore package installation, versioning, and semantic versioning (semver) using npm and yarn.</p></li>\n    <li><h3>package.json: Dependencies, devDependencies, scripts</h3>\n        <p>Understand the <code>package.json</code> file and its properties: dependencies, devDependencies, and scripts.</p></li>\n    <li><h3>Creating and Publishing Packages: Writing a modular library, npm publish</h3>\n        <p>Learn how to create and publish packages, including writing a modular library and using <code>npm publish</code>.</p></li>\n    <li><h3>Private Modules: Using private npm registries</h3>\n        <p>Explore how to use private npm registries for private modules.</p></li>\n    <li><h3>Module Bundlers: Webpack, Parcel (Basic integration)</h3>\n        <p>Get a basic understanding of module bundlers like Webpack and Parcel.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 4: Database Integration and ORMs</h2>\n  <p>This chapter covers advanced database integration techniques, including connection pooling, transaction management, and using ORMs (Object-Relational Mappers) for interacting with relational databases (e.g., PostgreSQL, MySQL).</p>\n  <ul>\n    <li><h3>Database Connection Pooling: Efficiently managing database connections</h3>\n        <p>Learn how to efficiently manage database connections using connection pooling.</p></li>\n    <li><h3>Transaction Management: Ensuring data consistency (ACID properties)</h3>\n        <p>Understand transaction management and how to ensure data consistency using ACID properties.</p></li>\n    <li><h3>SQL Injection Prevention: Parameterized queries, escaping user input</h3>\n        <p>Learn how to prevent SQL injection attacks using parameterized queries and escaping user input.</p></li>\n    <li><h3>ORMs: Sequelize, TypeORM (Concepts, basic usage)</h3>\n        <p>Explore ORMs like Sequelize and TypeORM and their basic usage.</p></li>\n    <li><h3>NoSQL Databases: MongoDB with Mongoose (Concepts, basic usage)</h3>\n        <p>Get a basic understanding of NoSQL databases like MongoDB with Mongoose.</p></li>\n    <li><h3>Data Modeling: Designing database schemas, indexes</h3>\n        <p>Learn how to design database schemas and indexes for optimal performance.</p></li>\n    <li><h3>Caching Strategies: Redis integration for improved performance</h3>\n        <p>Explore caching strategies and Redis integration for improved performance.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 5: Microservices Architecture</h2>\n  <p>This chapter explores the principles of microservices architecture, including service discovery, inter-service communication (REST, gRPC, message queues), and API gateways.</p>\n  <ul>\n    <li><h3>Microservices Principles: Decentralization, independent deployability, scalability</h3>\n        <p>Understand the principles of microservices: decentralization, independent deployability, and scalability.</p></li>\n    <li><h3>Service Discovery: Consul, etcd, Kubernetes DNS</h3>\n        <p>Explore different service discovery mechanisms like Consul, etcd, and Kubernetes DNS.</p></li>\n    <li><h3>Inter-Service Communication: REST APIs, gRPC, message queues (RabbitMQ, Kafka)</h3>\n        <p>Learn about inter-service communication patterns: REST APIs, gRPC, and message queues (RabbitMQ, Kafka).</p></li>\n    <li><h3>API Gateways: Handling routing, authentication, rate limiting</h3>\n        <p>Understand the role of API gateways and how they handle routing, authentication, and rate limiting.</p></li>\n    <li><h3>Containerization: Docker, Docker Compose</h3>\n        <p>Explore containerization using Docker and Docker Compose.</p></li>\n    <li><h3>Orchestration: Kubernetes (Basic concepts: Pods, Services, Deployments)</h3>\n        <p>Get a basic understanding of orchestration using Kubernetes (Pods, Services, Deployments).</p></li>\n    <li><h3>Event-Driven Architecture: Using message queues for asynchronous communication</h3>\n        <p>Learn how to use message queues for asynchronous communication in an event-driven architecture.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 6: Testing and Debugging</h2>\n  <p>This chapter covers advanced testing techniques, including unit testing, integration testing, end-to-end testing, and debugging strategies using Node.js debuggers and profiling tools.</p>\n  <ul>\n    <li><h3>Unit Testing: Mocha, Jest, Chai (Writing effective unit tests)</h3>\n        <p>Learn how to write effective unit tests using Mocha, Jest, and Chai.</p></li>\n    <li><h3>Integration Testing: Testing interactions between modules</h3>\n        <p>Understand how to test interactions between modules using integration testing.</p></li>\n    <li><h3>End-to-End Testing: Cypress, Puppeteer (Testing the entire application flow)</h3>\n        <p>Explore end-to-end testing using Cypress and Puppeteer for testing the entire application flow.</p></li>\n    <li><h3>Test Coverage: Measuring code coverage</h3>\n        <p>Learn how to measure code coverage to ensure thorough testing.</p></li>\n    <li><h3>Debugging Techniques: Using Node.js debugger, VS Code debugger</h3>\n        <p>Understand different debugging techniques using the Node.js debugger and VS Code debugger.</p></li>\n    <li><h3>Profiling: Identifying performance bottlenecks using Node.js profiling tools</h3>\n        <p>Learn how to identify performance bottlenecks using Node.js profiling tools.</p></li>\n    <li><h3>Logging: Implementing robust logging strategies (Winston, Morgan)</h3>\n        <p>Explore how to implement robust logging strategies using Winston and Morgan.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 7: Security Best Practices</h2>\n  <p>This chapter explores common security vulnerabilities in Node.js applications and best practices for mitigating them, including authentication, authorization, input validation, and protection against common web attacks.</p>\n  <ul>\n    <li><h3>Authentication: Passport.js, JWT (JSON Web Tokens), OAuth 2.0</h3>\n        <p>Learn about authentication mechanisms: Passport.js, JWT (JSON Web Tokens), and OAuth 2.0.</p></li>\n    <li><h3>Authorization: Role-based access control (RBAC), access control lists (ACLs)</h3>\n        <p>Understand authorization techniques: Role-based access control (RBAC) and access control lists (ACLs).</p></li>\n    <li><h3>Input Validation: Preventing injection attacks (SQL injection, XSS, command injection)</h3>\n        <p>Learn how to prevent injection attacks (SQL injection, XSS, command injection) through input validation.</p></li>\n    <li><h3>Cross-Site Scripting (XSS) Prevention: Sanitizing user input</h3>\n        <p>Explore how to prevent Cross-Site Scripting (XSS) by sanitizing user input.</p></li>\n    <li><h3>Cross-Site Request Forgery (CSRF) Prevention: Using CSRF tokens</h3>\n        <p>Learn how to prevent Cross-Site Request Forgery (CSRF) using CSRF tokens.</p></li>\n    <li><h3>HTTPS/TLS: Securing communication with SSL certificates</h3>\n        <p>Understand how to secure communication with SSL certificates using HTTPS/TLS.</p></li>\n    <li><h3>Security Headers: Implementing security headers (e.g., Content-Security-Policy)</h3>\n        <p>Explore how to implement security headers (e.g., Content-Security-Policy) for enhanced security.</p></li>\n    <li><h3>Dependency Security: Scanning dependencies for vulnerabilities (npm audit, Snyk)</h3>\n        <p>Learn how to scan dependencies for vulnerabilities using tools like <code>npm audit</code> and Snyk.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Chapter 8: Deployment and Production</h2>\n  <p>This chapter covers strategies for deploying Node.js applications to production environments, including process management, load balancing, monitoring, and scaling.</p>\n  <ul>\n    <li><h3>Process Management: PM2, Systemd (Ensuring application uptime)</h3>\n        <p>Learn how to ensure application uptime using process managers like PM2 and Systemd.</p></li>\n    <li><h3>Load Balancing: Nginx, HAProxy (Distributing traffic across multiple instances)</h3>\n        <p>Understand how to distribute traffic across multiple instances using load balancers like Nginx and HAProxy.</p></li>\n    <li><h3>Reverse Proxies: Configuring reverse proxies for security and performance</h3>\n        <p>Explore how to configure reverse proxies for security and performance.</p></li>\n    <li><h3>Monitoring: Prometheus, Grafana (Collecting metrics, setting up alerts)</h3>\n        <p>Learn how to collect metrics and set up alerts using monitoring tools like Prometheus and Grafana.</p></li>\n    <li><h3>Logging: Centralized logging (e.g., ELK stack)</h3>\n        <p>Understand the importance of centralized logging and how to implement it using tools like the ELK stack.</p></li>\n    <li><h3>Scaling Strategies: Horizontal scaling, vertical scaling</h3>\n        <p>Explore different scaling strategies: horizontal scaling and vertical scaling.</p></li>\n    <li><h3>Continuous Integration/Continuous Deployment (CI/CD): Setting up CI/CD pipelines</h3>\n        <p>Learn how to set up CI/CD pipelines for automated deployment.</p></li>\n  </ul>\n</section>\n\n<section>\n  <h2>Exam Tips</h2>\n  <ul>\n    <li>Thoroughly understand asynchronous programming concepts and the Node.js event loop.</li>\n    <li>Practice implementing various stream transformations and backpressure handling techniques.</li>\n    <li>Master module management and package publishing using npm/yarn.</li>\n    <li>Gain hands-on experience with database integration using ORMs and NoSQL databases.</li>\n    <li>Understand the principles of microservices architecture and different inter-service communication patterns.</li>\n    <li>Become proficient in writing unit, integration, and end-to-end tests.</li>\n    <li>Familiarize yourself with security best practices and common vulnerabilities in Node.js applications.</li>\n    <li>Learn different deployment strategies and tools for managing and monitoring Node.js applications in production.</li>\n    <li>Review the official Node.js documentation and relevant community resources.</li>\n    <li>Practice solving complex coding problems related to Node.js.</li>\n  </ul>\n</section>\n"},
          ],
        },
      ],
    });

    export const generateStudyTypeContentAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate flashcards on the topic: Python for data analytics in json format with front and back content. It can have a maximum of 20 cards"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n[\n  {\n    \"front\": \"What is NumPy and why is it used in data analytics?\",\n    \"back\": \"NumPy is a fundamental Python library for numerical computing. It provides efficient array operations, mathematical functions, and random number generation, crucial for data manipulation and analysis.\"\n  },\n  {\n    \"front\": \"Explain the purpose of Pandas in Python data analysis.\",\n    \"back\": \"Pandas is a library for data manipulation and analysis. It provides data structures like DataFrames and Series that allow you to easily clean, transform, and analyze tabular data.\"\n  },\n  {\n    \"front\": \"What is a Pandas DataFrame?\",\n    \"back\": \"A Pandas DataFrame is a two-dimensional labeled data structure with columns of potentially different types. It is similar to a spreadsheet or SQL table.\"\n  },\n  {\n    \"front\": \"How do you read a CSV file into a Pandas DataFrame?\",\n    \"back\": \"Using the `pd.read_csv()` function. Example: `df = pd.read_csv('my_data.csv')`\"\n  },\n  {\n    \"front\": \"What is data cleaning in the context of data analytics?\",\n    \"back\": \"Data cleaning is the process of identifying and correcting inaccurate, incomplete, irrelevant, or inconsistent data. It involves handling missing values, removing duplicates, and correcting data types.\"\n  },\n  {\n    \"front\": \"How can you handle missing values in a Pandas DataFrame?\",\n    \"back\": \"Using methods like `fillna()`, `dropna()`, or imputation techniques.\"\n  },\n  {\n    \"front\": \"What is data visualization and why is it important?\",\n    \"back\": \"Data visualization is the graphical representation of information and data. It's crucial for understanding patterns, trends, and insights from data, making it easier to communicate findings.\"\n  },\n  {\n    \"front\": \"Name a popular Python library for data visualization.\",\n    \"back\": \"Matplotlib and Seaborn are two popular libraries. Matplotlib is more fundamental, while Seaborn is built on top of Matplotlib and provides a higher-level interface for creating more aesthetically pleasing and informative visualizations.\"\n  },\n  {\n    \"front\": \"What are some common types of plots you can create with Matplotlib?\",\n    \"back\": \"Line plots, scatter plots, bar charts, histograms, pie charts, box plots.\"\n  },\n  {\n    \"front\": \"Explain the purpose of Seaborn in data visualization.\",\n    \"back\": \"Seaborn provides a high-level interface for creating informative and aesthetically pleasing statistical graphics. It simplifies the creation of complex visualizations.\"\n  },\n  {\n    \"front\": \"What is data aggregation and why is it useful?\",\n    \"back\": \"Data aggregation is the process of summarizing data into a more manageable form. It is useful for identifying trends, patterns, and insights in large datasets.\"\n  },\n  {\n    \"front\": \"How can you perform data aggregation in Pandas?\",\n    \"back\": \"Using the `groupby()` method followed by aggregation functions like `sum()`, `mean()`, `count()`, `min()`, `max()`.\"\n  },\n  {\n    \"front\": \"What is feature engineering?\",\n    \"back\": \"Feature engineering is the process of selecting, transforming, and creating new features from existing data to improve the performance of a machine learning model.\"\n  },\n  {\n    \"front\": \"What is data normalization or standardization?\",\n    \"back\": \"Scaling numerical data to a standard range (e.g., 0-1 or with mean 0 and standard deviation 1). This helps prevent features with larger scales from dominating the model.\"\n  },\n  {\n    \"front\": \"Explain the purpose of SciPy in data analysis.\",\n    \"back\": \"SciPy is a library for scientific computing that provides advanced mathematical, scientific, and engineering algorithms. Useful for statistical analysis, optimization, and signal processing.\"\n  },\n  {\n    \"front\": \"What is statistical inference?\",\n    \"back\": \"The process of drawing conclusions about a population based on a sample of data.  Involves hypothesis testing and confidence intervals.\"\n  },\n  {\n    \"front\": \"What is the purpose of hypothesis testing?\",\n    \"back\": \"To determine whether there is enough statistical evidence to reject a null hypothesis.\"\n  },\n  {\n    \"front\": \"What is correlation analysis?\",\n    \"back\": \"A statistical method used to determine the strength and direction of a linear relationship between two or more variables.\"\n  },\n   {\n    \"front\": \"What's a Jupyter Notebook and why is it useful for data analysis?\",\n    \"back\": \"It's an interactive computing environment allowing you to combine code, text, visualizations, and equations in a single document. Ideal for exploration, analysis, and documentation.\"\n  },\n  {\n    \"front\": \"What is the role of regular expressions (regex) in data analytics?\",\n    \"back\": \"Regular expressions are used for pattern matching in strings. They are useful for data cleaning, validation, and extraction of specific information from text data.\"\n  }\n]\n```"},
          ],
        },
      ],
    });

    export const generateQuizAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate Quiz on the topic: data structures and algorithms in java along with correct answers in json format."},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"quizTitle\": \"Data Structures and Algorithms in Java Quiz\",\n  \"description\": \"Test your knowledge of fundamental data structures and algorithms using Java.\",\n  \"questions\": [\n    {\n      \"questionText\": \"Which data structure follows the LIFO (Last-In, First-Out) principle?\",\n      \"options\": [\n        \"Queue\",\n        \"Stack\",\n        \"Linked List\",\n        \"Binary Tree\"\n      ],\n      \"correctAnswer\": \"Stack\",\n      \"answerExplanation\": \"A stack operates on the LIFO principle, where the last element added is the first one removed.\"\n    },\n    {\n      \"questionText\": \"What is the time complexity of searching for an element in a balanced binary search tree (BST)?\",\n      \"options\": [\n        \"O(n)\",\n        \"O(log n)\",\n        \"O(n log n)\",\n        \"O(1)\"\n      ],\n      \"correctAnswer\": \"O(log n)\",\n      \"answerExplanation\": \"Searching in a balanced BST takes logarithmic time (O(log n)) in the average and worst cases.\"\n    },\n    {\n      \"questionText\": \"Which sorting algorithm has the best average-case time complexity?\",\n      \"options\": [\n        \"Bubble Sort\",\n        \"Insertion Sort\",\n        \"Merge Sort\",\n        \"Selection Sort\"\n      ],\n      \"correctAnswer\": \"Merge Sort\",\n      \"answerExplanation\": \"Merge Sort has an average and worst-case time complexity of O(n log n), which is generally better than the other options.\"\n    },\n    {\n      \"questionText\": \"What is the purpose of a hash function in a hash table?\",\n      \"options\": [\n        \"To sort the elements in the table\",\n        \"To map keys to indices in the table\",\n        \"To resize the table when it's full\",\n        \"To delete elements from the table\"\n      ],\n      \"correctAnswer\": \"To map keys to indices in the table\",\n      \"answerExplanation\": \"A hash function is used to convert a key into an index in the hash table where the corresponding value can be stored or retrieved.\"\n    },\n    {\n      \"questionText\": \"Which of the following is an example of a non-linear data structure?\",\n      \"options\": [\n        \"Array\",\n        \"Linked List\",\n        \"Queue\",\n        \"Graph\"\n      ],\n      \"correctAnswer\": \"Graph\",\n      \"answerExplanation\": \"Graphs are non-linear data structures as they represent relationships between entities, unlike linear structures like arrays, linked lists, and queues.\"\n    },\n    {\n      \"questionText\": \"What is the purpose of the 'compareTo()' method in Java when implementing the Comparable interface?\",\n      \"options\": [\n        \"To check if two objects are equal\",\n        \"To compare two objects and determine their relative order\",\n        \"To convert an object to a string representation\",\n        \"To clone an object\"\n      ],\n      \"correctAnswer\": \"To compare two objects and determine their relative order\",\n      \"answerExplanation\": \"The compareTo() method defines the natural ordering of objects of a class. It returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\"\n    },\n    {\n      \"questionText\": \"Which data structure is best suited for implementing a priority queue?\",\n      \"options\": [\n        \"Stack\",\n        \"Queue\",\n        \"Heap\",\n        \"Linked List\"\n      ],\n      \"correctAnswer\": \"Heap\",\n      \"answerExplanation\": \"Heaps are specifically designed for priority queues because they efficiently maintain the property that the element with the highest (or lowest) priority is always at the root.\"\n    },\n    {\n      \"questionText\": \"What is the time complexity of inserting an element at the beginning of a singly linked list?\",\n      \"options\": [\n        \"O(1)\",\n        \"O(n)\",\n        \"O(log n)\",\n        \"O(n log n)\"\n      ],\n      \"correctAnswer\": \"O(1)\",\n      \"answerExplanation\": \"Inserting at the beginning of a singly linked list requires only updating the head pointer, which takes constant time (O(1)).\"\n    },\n    {\n      \"questionText\": \"Which searching algorithm requires the data to be sorted?\",\n      \"options\": [\n        \"Linear Search\",\n        \"Binary Search\",\n        \"Depth-First Search\",\n        \"Breadth-First Search\"\n      ],\n      \"correctAnswer\": \"Binary Search\",\n      \"answerExplanation\": \"Binary search requires the data to be sorted because it repeatedly divides the search interval in half.\"\n    },\n    {\n      \"questionText\": \"What is the main advantage of using a doubly linked list over a singly linked list?\",\n      \"options\": [\n        \"More efficient insertion at the beginning\",\n        \"More efficient traversal in both directions\",\n        \"Less memory usage\",\n        \"Simpler implementation\"\n      ],\n      \"correctAnswer\": \"More efficient traversal in both directions\",\n      \"answerExplanation\": \"Doubly linked lists allow traversal in both directions (forward and backward), which can be useful for certain operations. Singly linked lists only allow traversal in one direction.\"\n    }\n  ]\n}\n```\n"},
          ],
        },
      ],
    })
  
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // // TODO: Following code needs to be updated for client-side apps.
    // const candidates = result.response.candidates;
    // for(let candidate_index = 0; candidate_index < candidates.length; candidate_index++) {
    //   for(let part_index = 0; part_index < candidates[candidate_index].content.parts.length; part_index++) {
    //     const part = candidates[candidate_index].content.parts[part_index];
    //     if(part.inlineData) {
    //       try {
    //         const filename = `output_${candidate_index}_${part_index}.${mime.extension(part.inlineData.mimeType)}`;
    //         fs.writeFileSync(filename, Buffer.from(part.inlineData.data, 'base64'));
    //         console.log(`Output written to: ${filename}`);
    //       } catch (err) {
    //         console.error(err);
    //       }
    //     }
    //   }
    // }
    // console.log(result.response.text());
 